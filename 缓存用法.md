
#### 使用场景
1. 缓存的，使用场景
(实时性不高 或 数据更新不频繁) 且 (查询频繁 或 查询较慢）。
	1. 实时性高且数据更新频繁的数据，不适合使用缓存。
	2. 查询频繁
	根据二八定律，热点数据一般只有20%。
2. 缓存的，同步方案
	1. 影响缓存同步方案的因素:实时性要求、数据更新频率、数据查询速度。
	2. 方案1:不同步 + 支持过期击穿
	适用于:实时性要求不高（无法满足实时性要求时，可以试着减少过期时间）、且数据查询不慢。
		1. 不同步
		是指，可以给缓存中元素，设置生存时间。超过时间，则从缓存中删除元素。
		2. 支持过期击穿
		是指，查询时，先去缓存中获取，存在时直接返回；不存在时，则去数据源中查询，再将查询结果加入缓存。
			1. 缓存中不存在的数据，去数据源中查询没有结果时，可以把Null对象当成value，存进缓存。这样可以避免不存在数据的大量访问，对数据源造成压力。
	2. 同步
	不设置过期时间，需要手动更新缓存。
		1. 方案
			1. 方案2:数据改变时能主动去修改缓存。 
				1. 适用于:实时性要求高、且数据更新不频繁
				2. 不适合，使用本地缓存。
				3. 方案实现
					1. 数据源发生修改时，向消息中心发送消息。服务端监听消息来清除本地缓存。
					2. 服务端向数据源注册同步接口，数据源发生修改时调用接口。
						1. 数据源由dubbo提供，则可以将同步接口注册为服务。
						2. 将同步接口注册为指定uri的Controller。注意，
							1. 数据源要通过其他方式获得host
							2. 本地缓存所在服务，如果是集群，数据源调用uri不能清除所有集群节点。
					3. 数据源除了提供数据接口，还提供一个查询变动的接口。服务端定时调用查询接口，根据返回清除本地缓存。
						1. 如果数据源布置成了集群，则在节点1发生了变动，需要从节点2能够查询到变动。实现可以参考: 集群节点的本地缓存发生更新，如何相互通知.md
			2. 方案3:数据改变时无法主动修改，可以使用定时任务去定时更新缓存。定时间隔，即相当于过期时间。
				1. 定时任务中，还可以先判断发生了修改，才去更新缓存。
				2. 适用于:实时性要求不高
		3. 缓存前置（服务层提供的client中进行缓存，避免rpc）时
		要实现同步，需要接入client的客户端，和服务端，使用同一个分布式缓存。
		4. web层和服务层
		服务层提供的方法，因为不清楚使用情景，也就不清楚实时性要求（web层才清楚），所以尽量提供实时的。
			1. 接口较慢、且接口实时性要求不高时，优先在web层，加缓存解决。而不是要求服务层方法，去加缓存（会变成非实时方法，与上面的原则不符）。  
				1. web层缓存，只要支持过期击穿即可。
			2. 如果接口实时性要求高，web层加缓存则无法解决问题，则可以要求服务层方法，去解决执行速度和实时性的问题。
				1. web层缓存，难以实现数据变更的同步，所以只能用于，实时性要求不高的接口。
			3. 少数情况:接口实时性要求不高，但web层加缓存，还是无法解决问题。--没想到案例。
			才可以要求服务层方法，去加缓存。
				1. 服务层非实时的方法，最好在方法名或类名中，标明出来。
		5. 一般是把数据源的多个数据聚合后缓存，某项数据修改后，需要一些额外的查询，才能生成缓存的key，进而才能删除缓存。
		6. 服务链路的各个层级（比如:浏览器->代理->路由等）都可能有缓存，最上层对最下层（数据源）的结构并不清楚，难以处理其修改的通知。
		只对最下层有用，无法用于上层的缓存。
3. 缓存的，开关方案
上级调用下级时，传递一个参数，告诉下级不要缓存。这个参数一层层传递下去；则这个调用不会使用缓存。
适用于:有时，调用频繁、且实时性要求不高（使用缓存）。有时，调用不频繁、实时性要求高（不使用缓存）。
	1. 以上情况，好像很少。
	比如:缓存开关（有缓存的调用，加上开关，来快速修复缓存带来的问题）
4. 缓存框架选择:memcache、redis、本地缓存
	1. 实时性
		1. 要求高:分布式缓存（包括:memcache、redis）
			1. 本地缓存，分布在集群的每台服务器，清除比较麻烦。
		2. 要求不高:均可
	2. 数据量
		1. 大:分布式缓存
			1. 本地缓存，会占用过多内存。
		2. 小:均可
	3. 一致性
		1. 有要求:分布式缓存
		2. 无要求:均可
			1. 本地缓存，分布在集群的每台服务器，一致性难以保证。
	4. 缓存key是否可控
	即，缓存key是否是用户输入。
		1. 不可控:分布式缓存
			1. redis的过期策略，支持设置了过期时间但未过期的key，在内存不足时也释放掉。
		2. 可控:均可
	5. 击穿的兜底策略
		1. 没有做:redis（redis支持持久化）
			1. 数据更新，还要配合同步。
			2. 不设置过期时间。避免因为内存不足，被释放掉。
		2. 做了:均可
	6. 总之:优先级从上往下，依次进行框架选择。
	>	
		没有做击穿的兜底策略，使用redis。
		缓存数量不可控，使用分布式缓存。
		实时性要求高，使用分布式缓存。
		数据量大，使用分布式缓存。
		一致性有要求，使用分布式缓存
		访问非常非常的频繁，使用本地缓存；否则尽量使用分布式缓存。

#### memcached和redis 比较
https://mp.weixin.qq.com/s/9glDEBcZf6i9-Vs3XlcEig

1. memcached
	1. 支持分布式
	采用一致性哈希算法，向节点分配数据。
	2. 不支持数据防丢
		1. 必须实现，击穿后去获取数据。
	3. 不支持主从同步
	也就无法支持:读写分离、数据快速恢复。
		1. 需要第三方框架支持，也能实现。
	4. 多线程
	并发>核数时，可能产生频繁的上下文切换；尤其是缓存值较小时。性能不如redis。
	5. 数据，结构单一、限制较多
	仅支持string、value最大1M、过期时间不能超过30天
	6. 过期策略
	只支持LRU。这样，即使key没有过期，内存不足时，还是会释放掉。
2. redis
	1. 支持分布式
	采用一致性哈希算法，向节点分配数据。
		1. 可用框架
		Redis cluster（无中心化的设计）、Codis、Twemproxy
		2. 每个节点，都支持主从同步。
	2. 支持数据防丢和快速恢复
	配合同步方案时，可以不考虑击穿的情况。
		1. 支持持久化
			2. 提供RDB和AOF，两种持久化方式
				1. RDB
				将整个实例中的数据快照到磁盘上，全量持久化
				2. AOF
				把每一个写命令持久到磁盘，增量持久化
				3. Redis会两种方式配合一起使用
		2. 支持主从同步
		主数据崩溃时，哨兵节点会将对其的操作，转移到从库。从而快速恢复数据。
	3. 支持主从同步
	也就支持了:读写分离、数据快速恢复
	4. 单线程
	并发>1时，可能产生较多的排队开销；尤其是缓存值较大时。性能不如memcached（可以布置成集群）。
		1. 推测
		缓存值适中 且 1<并发<核数；redis，性能不如memcached。
		但，但redis采用了IO多路复用，并在接收和发送请求时使用了多线程。差距不会太大。
	5. 数据，结构较多、限制较少
	最大value限制较高、没有过期时间限制。
	6. 过期策略
	支持，设置过期时间但未过期的key，在内存不足时也释放掉。
	也支持，不设置过期时间，在内存不足时也不释放。

